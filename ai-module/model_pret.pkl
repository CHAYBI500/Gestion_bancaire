from flask import Flask, jsonify
import mysql.connector
import joblib
import pandas as pd
import matplotlib
matplotlib.use('Agg')  # Mode non-interactif
import matplotlib.pyplot as plt
import seaborn as sns
import os
from datetime import datetime
import logging

# Configuration du logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)

# ========================
# Configuration
# ========================
DB_CONFIG = {
    "host": "localhost",
    "user": "root",
    "password": "",
    "database": "pret_bancaires"
}

GRAPHS_DIR = "static/graphs"

# Cr√©er le dossier pour les graphiques s'il n'existe pas
os.makedirs(GRAPHS_DIR, exist_ok=True)

# ========================
# Chargement du mod√®le IA
# ========================
try:
    model = joblib.load("model_pret.pkl")
    logger.info("‚úì Mod√®le charg√© avec succ√®s")
except Exception as e:
    logger.error(f"‚ùå Erreur chargement mod√®le: {e}")
    model = None

# ========================
# Fonction de pr√©diction automatique
# ========================
def auto_predict_new_loans():
    """
    V√©rifie automatiquement s'il y a de nouveaux pr√™ts sans pr√©diction
    et effectue les pr√©dictions
    """
    if model is None:
        logger.error("Mod√®le non charg√©")
        return {"success": False, "message": "Mod√®le non disponible"}
    
    try:
        conn = mysql.connector.connect(**DB_CONFIG)
        cursor = conn.cursor(dictionary=True)
        
        # R√©cup√©rer les pr√™ts sans pr√©diction
        cursor.execute("""
            SELECT 
                p.id_pret,
                c.revenu_mensuel AS revenu,
                p.duree_mois AS duree,
                p.taux_annuel AS taux_annuel,
                p.mensualite
            FROM pret p
            JOIN client c ON p.client_id = c.id_client
            LEFT JOIN prediction_risque pr ON p.id_pret = pr.pret_id
            WHERE pr.pret_id IS NULL AND c.revenu_mensuel > 0
        """)
        
        prets = cursor.fetchall()
        
        if not prets:
            logger.info("Aucun nouveau pr√™t √† pr√©dire")
            cursor.close()
            conn.close()
            return {"success": True, "message": "Aucun nouveau pr√™t", "count": 0}
        
        # Cr√©er DataFrame
        df = pd.DataFrame(prets)
        
        # Calcul du taux d'endettement
        df['taux_endettement'] = df['mensualite'] / df['revenu']
        
        # Pr√©diction
        df['niveau_risque'] = model.predict(df[['taux_endettement']])
        
        # Ins√©rer les pr√©dictions
        predictions_count = 0
        for _, row in df.iterrows():
            cursor.execute("""
                INSERT INTO prediction_risque 
                (pret_id, taux_endettement, niveau_risque, score_confiance, date_prediction)
                VALUES (%s, %s, %s, %s, NOW())
            """, (
                row['id_pret'], 
                float(row['taux_endettement']), 
                row['niveau_risque'], 
                0.85
            ))
            predictions_count += 1
        
        conn.commit()
        
        # R√©sum√© des pr√©dictions
        risque_summary = df['niveau_risque'].value_counts().to_dict()
        
        cursor.close()
        conn.close()
        
        logger.info(f"‚úì {predictions_count} pr√©dictions effectu√©es: {risque_summary}")
        
        return {
            "success": True,
            "message": f"{predictions_count} pr√©dictions effectu√©es",
            "count": predictions_count,
            "summary": risque_summary
        }
        
    except Exception as e:
        logger.error(f"Erreur lors de la pr√©diction: {e}")
        return {"success": False, "message": str(e)}

# ========================
# G√©n√©ration des graphiques
# ========================
def generate_analytics_graphs():
    """
    G√©n√®re les graphiques d'analyse pour le dashboard
    """
    try:
        conn = mysql.connector.connect(**DB_CONFIG)
        cursor = conn.cursor(dictionary=True)
        
        # 1. R√©partition des risques
        cursor.execute("""
            SELECT niveau_risque, COUNT(*) AS total
            FROM prediction_risque
            GROUP BY niveau_risque
        """)
        risques = cursor.fetchall()
        
        if risques:
            risque_df = pd.DataFrame(risques)
            
            plt.figure(figsize=(10, 6))
            colors = {'Faible': '#16a34a', 'Moyen': '#facc15', '√âlev√©': '#dc2626'}
            bar_colors = [colors.get(r, '#6b7280') for r in risque_df['niveau_risque']]
            
            plt.bar(risque_df['niveau_risque'], risque_df['total'], color=bar_colors, edgecolor='white', linewidth=2)
            plt.title('R√©partition des Pr√™ts par Niveau de Risque', fontsize=14, fontweight='bold', pad=20)
            plt.ylabel('Nombre de Pr√™ts', fontsize=11)
            plt.xlabel('Niveau de Risque', fontsize=11)
            plt.grid(axis='y', alpha=0.3)
            plt.tight_layout()
            plt.savefig(f'{GRAPHS_DIR}/repartition_risques.png', dpi=100, bbox_inches='tight')
            plt.close()
        
        # 2. Distribution de l'endettement
        cursor.execute("SELECT taux_endettement FROM prediction_risque WHERE taux_endettement IS NOT NULL")
        te_data = [row['taux_endettement'] for row in cursor.fetchall()]
        
        if te_data:
            plt.figure(figsize=(10, 6))
            plt.hist(te_data, bins=25, color='#3b82f6', alpha=0.7, edgecolor='white', linewidth=1.2)
            plt.axvline(x=0.33, color='red', linestyle='--', linewidth=2, label='Seuil 33%')
            plt.title('Distribution du Taux d\'Endettement', fontsize=14, fontweight='bold', pad=20)
            plt.xlabel('Taux d\'Endettement', fontsize=11)
            plt.ylabel('Fr√©quence', fontsize=11)
            plt.legend()
            plt.grid(axis='y', alpha=0.3)
            plt.tight_layout()
            plt.savefig(f'{GRAPHS_DIR}/distribution_endettement.png', dpi=100, bbox_inches='tight')
            plt.close()
        
        # 3. √âvolution des risques dans le temps
        cursor.execute("""
            SELECT DATE(date_prediction) AS date, niveau_risque, COUNT(*) AS total
            FROM prediction_risque
            GROUP BY DATE(date_prediction), niveau_risque
            ORDER BY date
        """)
        evolution = cursor.fetchall()
        
        if evolution:
            evo_df = pd.DataFrame(evolution)
            pivot_df = evo_df.pivot(index='date', columns='niveau_risque', values='total').fillna(0)
            
            plt.figure(figsize=(10, 6))
            pivot_df.plot(kind='area', stacked=True, ax=plt.gca(), 
                         color=['#16a34a', '#facc15', '#dc2626'], alpha=0.7)
            plt.title('√âvolution des Risques dans le Temps', fontsize=14, fontweight='bold', pad=20)
            plt.xlabel('Date', fontsize=11)
            plt.ylabel('Nombre de Pr√™ts', fontsize=11)
            plt.legend(title='Niveau de Risque', loc='upper left')
            plt.grid(axis='y', alpha=0.3)
            plt.tight_layout()
            plt.savefig(f'{GRAPHS_DIR}/evolution_risques.png', dpi=100, bbox_inches='tight')
            plt.close()
        
        # 4. Matrice de corr√©lation
        cursor.execute("""
            SELECT pr.taux_endettement, p.mensualite, c.revenu_mensuel, p.duree_mois
            FROM prediction_risque pr
            JOIN pret p ON pr.pret_id = p.id_pret
            JOIN client c ON p.client_id = c.id_client
            WHERE pr.taux_endettement IS NOT NULL
        """)
        corr_data = cursor.fetchall()
        
        if corr_data:
            corr_df = pd.DataFrame(corr_data)
            corr_matrix = corr_df.corr()
            
            plt.figure(figsize=(8, 6))
            sns.heatmap(corr_matrix, annot=True, fmt='.2f', cmap='coolwarm', 
                       square=True, linewidths=1, cbar_kws={"shrink": 0.8})
            plt.title('Matrice de Corr√©lation', fontsize=14, fontweight='bold', pad=20)
            plt.tight_layout()
            plt.savefig(f'{GRAPHS_DIR}/correlation_matrix.png', dpi=100, bbox_inches='tight')
            plt.close()
        
        cursor.close()
        conn.close()
        
        logger.info("‚úì Graphiques g√©n√©r√©s avec succ√®s")
        return {"success": True, "message": "Graphiques g√©n√©r√©s"}
        
    except Exception as e:
        logger.error(f"Erreur g√©n√©ration graphiques: {e}")
        return {"success": False, "message": str(e)}

# ========================
# ROUTES API
# ========================

@app.route("/predict/auto", methods=["POST"])
def auto_predict():
    """
    Route pour d√©clencher manuellement la pr√©diction automatique
    """
    result = auto_predict_new_loans()
    return jsonify(result)

@app.route("/graphs/generate", methods=["POST"])
def generate_graphs():
    """
    Route pour g√©n√©rer les graphiques
    """
    result = generate_analytics_graphs()
    return jsonify(result)

@app.route("/report", methods=["GET"])
def report():
    """
    Rapport global avec g√©n√©ration automatique des graphiques
    """
    # D'abord, v√©rifier et pr√©dire les nouveaux pr√™ts
    auto_predict_new_loans()
    
    # G√©n√©rer les graphiques
    generate_analytics_graphs()
    
    # R√©cup√©rer les donn√©es
    conn = mysql.connector.connect(**DB_CONFIG)
    cursor = conn.cursor(dictionary=True)
    
    cursor.execute("""
        SELECT niveau_risque, COUNT(*) AS total
        FROM prediction_risque
        GROUP BY niveau_risque
    """)
    risques = cursor.fetchall()
    
    cursor.execute("SELECT COUNT(*) AS total_prets FROM pret")
    total_prets = cursor.fetchone()["total_prets"]
    
    cursor.close()
    conn.close()
    
    return jsonify({
        "total_prets": total_prets,
        "repartition_risque": risques,
        "graphs_generated": True,
        "timestamp": datetime.now().isoformat()
    })

@app.route("/health", methods=["GET"])
def health():
    """
    V√©rification de l'√©tat du service
    """
    return jsonify({
        "status": "running",
        "model_loaded": model is not None,
        "timestamp": datetime.now().isoformat()
    })

# ========================
# D√©marrage de l'application
# ========================
if __name__ == "__main__":
    logger.info("üöÄ D√©marrage du serveur Flask IA")
    logger.info("üìä V√©rification initiale des pr√©dictions...")
    
    # Pr√©dictions initiales au d√©marrage
    auto_predict_new_loans()
    generate_analytics_graphs()
    
    app.run(debug=True, host='0.0.0.0', port=5000)